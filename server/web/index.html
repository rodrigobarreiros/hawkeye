<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hawkeye Video Pipeline - Live Stream</title>

    <!-- HLS.js library -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

    <style>
        :root {
            --bg-primary: #0f1419;
            --bg-secondary: #1a1d23;
            --bg-card: linear-gradient(135deg, #1a1d23 0%, #252a31 100%);
            --border: #2d3139;
            --text-primary: #ffffff;
            --text-secondary: #d4d4d4;
            --text-muted: #9e9e9e;
            --accent-primary: #00d4ff;
            --accent-webrtc: #667eea;
            --accent-hls: #81c784;
            --accent-rtsp: #ffc107;
            --accent-srt: #f06292;
            --success: #28a745;
            --warning: #ffc107;
            --error: #dc3545;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: var(--bg-primary);
            color: var(--text-secondary);
            min-height: 100vh;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border);
        }

        .header-left h1 {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header-left .subtitle {
            color: var(--text-muted);
            font-size: 0.9rem;
            margin-top: 4px;
        }

        .system-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(40, 167, 69, 0.1);
            border: 1px solid rgba(40, 167, 69, 0.3);
            border-radius: 20px;
            font-size: 0.85rem;
            color: var(--success);
        }

        .system-status.warning {
            background: rgba(255, 193, 7, 0.1);
            border-color: rgba(255, 193, 7, 0.3);
            color: var(--warning);
        }

        .system-status.error {
            background: rgba(220, 53, 69, 0.1);
            border-color: rgba(220, 53, 69, 0.3);
            color: var(--error);
        }

        /* Protocol Selector */
        .protocol-selector {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .protocol-btn {
            flex: 1;
            min-width: 160px;
            padding: 16px 20px;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            color: var(--text-secondary);
        }

        .protocol-btn:hover {
            border-color: var(--accent-primary);
            transform: translateY(-2px);
        }

        .protocol-btn.active {
            border-color: var(--accent-primary);
            background: rgba(0, 212, 255, 0.1);
        }

        .protocol-btn.webrtc.active { border-color: var(--accent-webrtc); background: rgba(102, 126, 234, 0.15); }
        .protocol-btn.hls.active { border-color: var(--accent-hls); background: rgba(129, 199, 132, 0.15); }
        .protocol-btn.rtsp.active { border-color: var(--accent-rtsp); background: rgba(255, 193, 7, 0.15); }
        .protocol-btn.srt.active { border-color: var(--accent-srt); background: rgba(240, 98, 146, 0.15); }

        .protocol-btn .icon {
            font-size: 1.5rem;
            display: block;
            margin-bottom: 8px;
        }

        .protocol-btn .name {
            font-weight: 600;
            font-size: 1rem;
            color: var(--text-primary);
            display: block;
        }

        .protocol-btn .latency {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 4px;
        }

        /* Main Grid */
        .main-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 1100px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Video Container */
        .video-section {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            overflow: hidden;
        }

        .video-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
        }

        .video-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--text-muted);
        }

        .status-dot.connected {
            background: var(--success);
            box-shadow: 0 0 10px var(--success);
        }

        .status-dot.connecting {
            background: var(--warning);
            animation: blink 1s infinite;
        }

        .status-dot.error {
            background: var(--error);
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .video-container {
            position: relative;
            width: 100%;
            background: #000;
            aspect-ratio: 16/9;
            min-height: 360px;
        }

        .video-container video {
            width: 100%;
            height: 100%;
            display: block;
        }

        .video-container video.hidden,
        .video-container .player-panel.hidden {
            display: none;
        }

        .video-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.85);
            color: var(--text-primary);
            z-index: 10;
        }

        .video-overlay.hidden {
            display: none;
        }

        .video-overlay .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .video-overlay .message {
            font-size: 1rem;
            color: var(--text-secondary);
        }

        /* External Player Panel */
        .player-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg-secondary);
            padding: 40px;
            text-align: center;
        }

        .player-panel .icon-large {
            font-size: 4rem;
            margin-bottom: 20px;
        }

        .player-panel h3 {
            font-size: 1.3rem;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .player-panel .description {
            color: var(--text-muted);
            margin-bottom: 24px;
            max-width: 400px;
        }

        .instruction-box {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            width: 100%;
            max-width: 500px;
            text-align: left;
        }

        .instruction-box h4 {
            color: var(--text-primary);
            font-size: 0.9rem;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .instruction-box ol {
            margin-left: 20px;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .instruction-box ol li {
            margin-bottom: 8px;
        }

        .instruction-box code {
            background: rgba(0, 212, 255, 0.1);
            color: var(--accent-primary);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 0.85rem;
        }

        .url-copy-box {
            display: flex;
            gap: 10px;
            margin-top: 16px;
        }

        .url-copy-box input {
            flex: 1;
            padding: 12px 16px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--accent-primary);
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 0.85rem;
        }

        .url-copy-box input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: var(--accent-primary);
            color: var(--bg-primary);
        }

        .btn-primary:hover {
            background: #00b8db;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .video-controls {
            display: flex;
            gap: 10px;
            padding: 16px 20px;
            border-top: 1px solid var(--border);
            flex-wrap: wrap;
        }

        /* Protocol Info Table */
        .protocol-info {
            margin-top: 20px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
        }

        .protocol-info table {
            width: 100%;
            border-collapse: collapse;
        }

        .protocol-info th,
        .protocol-info td {
            padding: 14px 16px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .protocol-info th {
            background: var(--bg-secondary);
            color: var(--text-muted);
            font-size: 0.75rem;
            text-transform: uppercase;
            font-weight: 600;
        }

        .protocol-info tr:last-child td {
            border-bottom: none;
        }

        .protocol-info td {
            font-size: 0.9rem;
        }

        .protocol-info .protocol-name {
            font-weight: 600;
            color: var(--text-primary);
        }

        .protocol-info .url-cell {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 0.8rem;
            color: var(--accent-primary);
        }

        .protocol-info .copy-btn {
            padding: 6px 12px;
            font-size: 0.75rem;
        }

        .latency-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .latency-badge.ultra-low {
            background: rgba(102, 126, 234, 0.2);
            color: var(--accent-webrtc);
        }

        .latency-badge.low {
            background: rgba(240, 98, 146, 0.2);
            color: var(--accent-srt);
        }

        .latency-badge.medium {
            background: rgba(255, 193, 7, 0.2);
            color: var(--accent-rtsp);
        }

        .latency-badge.high {
            background: rgba(129, 199, 132, 0.2);
            color: var(--accent-hls);
        }

        /* Right Sidebar */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Pipeline Status Cards */
        .pipeline-status {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
        }

        .pipeline-status h3 {
            font-size: 1rem;
            color: var(--text-primary);
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .pipeline-card {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 16px;
            margin-bottom: 12px;
            transition: all 0.2s;
        }

        .pipeline-card:last-child {
            margin-bottom: 0;
        }

        .pipeline-card:hover {
            border-color: var(--accent-primary);
        }

        .pipeline-card .pipeline-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
        }

        .pipeline-card .pipeline-name {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .pipeline-card .pipeline-icon {
            font-size: 1.2rem;
        }

        .pipeline-card .pipeline-status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .pipeline-card .pipeline-status-badge.streaming {
            background: rgba(40, 167, 69, 0.15);
            color: var(--success);
        }

        .pipeline-card .pipeline-status-badge.connecting {
            background: rgba(255, 193, 7, 0.15);
            color: var(--warning);
        }

        .pipeline-card .pipeline-status-badge.error {
            background: rgba(220, 53, 69, 0.15);
            color: var(--error);
        }

        .pipeline-card .pipeline-details {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .pipeline-card .pipeline-details span {
            display: flex;
            justify-content: space-between;
        }

        .pipeline-card .pipeline-details .value {
            color: var(--text-secondary);
            font-family: 'SF Mono', Monaco, monospace;
        }

        /* Metrics Cards */
        .metrics-section {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
        }

        .metrics-section h3 {
            font-size: 1rem;
            color: var(--text-primary);
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .refresh-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            color: var(--text-muted);
            font-weight: normal;
        }

        .refresh-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .metric-card {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 16px;
            text-align: center;
            transition: all 0.2s;
        }

        .metric-card:hover {
            transform: translateY(-2px);
            border-color: var(--accent-primary);
        }

        .metric-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--text-primary);
            line-height: 1;
        }

        .metric-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-top: 6px;
            letter-spacing: 0.5px;
        }

        /* Connection Stats */
        .connection-stats {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border);
        }

        .connection-stats h4 {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 12px;
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--border);
        }

        .stats-row:last-child {
            border-bottom: none;
        }

        .stats-row .label {
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        .stats-row .value {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 14px 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        .toast.success {
            border-color: var(--success);
        }

        .toast.error {
            border-color: var(--error);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .protocol-selector {
                flex-direction: column;
            }

            .protocol-btn {
                min-width: 100%;
            }

            .metrics-grid {
                grid-template-columns: 1fr;
            }

            header {
                flex-direction: column;
                gap: 16px;
                text-align: center;
            }

            .video-controls {
                flex-direction: column;
            }

            .video-controls .btn {
                width: 100%;
                justify-content: center;
            }

            .url-copy-box {
                flex-direction: column;
            }

            .protocol-info {
                overflow-x: auto;
            }

            .protocol-info table {
                min-width: 600px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-left">
                <h1>Hawkeye Video Pipeline</h1>
                <p class="subtitle">Multi-Protocol Live Streaming Dashboard</p>
            </div>
            <div class="system-status" id="systemStatus">
                <span class="status-dot connected"></span>
                <span>All Systems Operational</span>
            </div>
        </header>

        <!-- Protocol Selector -->
        <div class="protocol-selector" role="tablist">
            <button class="protocol-btn webrtc active" data-protocol="webrtc" role="tab" aria-selected="true" onclick="switchProtocol('webrtc')">
                <span class="icon">&#9889;</span>
                <span class="name">WebRTC</span>
                <span class="latency">Ultra Low Latency (~200ms)</span>
            </button>
            <button class="protocol-btn hls" data-protocol="hls" role="tab" aria-selected="false" onclick="switchProtocol('hls')">
                <span class="icon">&#127760;</span>
                <span class="name">HLS</span>
                <span class="latency">Reliable Streaming (~8s)</span>
            </button>
            <button class="protocol-btn rtsp" data-protocol="rtsp" role="tab" aria-selected="false" onclick="switchProtocol('rtsp')">
                <span class="icon">&#128225;</span>
                <span class="name">RTSP</span>
                <span class="latency">Low Latency (~1s)</span>
            </button>
            <button class="protocol-btn srt" data-protocol="srt" role="tab" aria-selected="false" onclick="switchProtocol('srt')">
                <span class="icon">&#128640;</span>
                <span class="name">SRT</span>
                <span class="latency">Very Low Latency (~500ms)</span>
            </button>
        </div>

        <div class="main-grid">
            <!-- Video Player Section -->
            <div class="video-section">
                <div class="video-header">
                    <span class="video-title" id="playerTitle">Camera 1 - WebRTC</span>
                    <div class="connection-status">
                        <span class="status-dot" id="statusDot"></span>
                        <span id="statusText">Disconnected</span>
                    </div>
                </div>

                <div class="video-container">
                    <!-- WebRTC Player -->
                    <video id="webrtc-player" autoplay muted playsinline controls></video>

                    <!-- HLS Player -->
                    <video id="hls-player" class="hidden" autoplay muted playsinline controls></video>

                    <!-- RTSP Instructions -->
                    <div id="rtsp-panel" class="player-panel hidden">
                        <span class="icon-large">&#128225;</span>
                        <h3>RTSP Stream</h3>
                        <p class="description">RTSP streams cannot play directly in the browser. Use an external player like VLC.</p>
                        <div class="instruction-box">
                            <h4>&#128214; How to Watch</h4>
                            <ol>
                                <li>Open <strong>VLC Media Player</strong></li>
                                <li>Go to <strong>Media</strong> &rarr; <strong>Open Network Stream</strong></li>
                                <li>Enter the URL below and click <strong>Play</strong></li>
                            </ol>
                            <div class="url-copy-box">
                                <input type="text" id="rtsp-url" readonly>
                                <button class="btn btn-primary" onclick="copyUrl('rtsp-url')">Copy</button>
                            </div>
                            <p style="margin-top: 12px; font-size: 0.8rem; color: var(--text-muted);">
                                Alternative: <code>ffplay "<span class="rtsp-url-text"></span>"</code>
                            </p>
                        </div>
                    </div>

                    <!-- SRT Instructions -->
                    <div id="srt-panel" class="player-panel hidden">
                        <span class="icon-large">&#128640;</span>
                        <h3>SRT Stream</h3>
                        <p class="description">SRT (Secure Reliable Transport) provides low-latency streaming. Use VLC 3.0+ or OBS Studio.</p>
                        <div class="instruction-box">
                            <h4>&#128214; How to Watch</h4>
                            <ol>
                                <li>Open <strong>VLC 3.0+</strong> or <strong>OBS Studio</strong></li>
                                <li>Go to <strong>Media</strong> &rarr; <strong>Open Network Stream</strong></li>
                                <li>Enter the URL below (including quotes in terminal)</li>
                            </ol>
                            <div class="url-copy-box">
                                <input type="text" id="srt-url" readonly>
                                <button class="btn btn-primary" onclick="copyUrl('srt-url')">Copy</button>
                            </div>
                            <p style="margin-top: 12px; font-size: 0.8rem; color: var(--text-muted);">
                                Alternative: <code>ffplay "<span class="srt-url-text"></span>"</code>
                            </p>
                        </div>
                    </div>

                    <!-- Loading Overlay -->
                    <div class="video-overlay" id="overlay">
                        <div class="spinner"></div>
                        <span class="message" id="overlayMessage">Connecting...</span>
                    </div>
                </div>

                <div class="video-controls">
                    <button class="btn btn-primary" id="connectBtn" onclick="connectCurrentProtocol()">
                        <span>&#9654;</span> Connect
                    </button>
                    <button class="btn btn-secondary" onclick="disconnectCurrentProtocol()">
                        <span>&#9632;</span> Disconnect
                    </button>
                    <button class="btn btn-secondary" onclick="toggleFullscreen()">
                        <span>&#x26F6;</span> Fullscreen
                    </button>
                    <button class="btn btn-secondary" onclick="togglePiP()">
                        <span>&#128250;</span> Picture-in-Picture
                    </button>
                </div>
            </div>

            <!-- Sidebar -->
            <div class="sidebar">
                <!-- Pipeline Status -->
                <div class="pipeline-status">
                    <h3>&#128204; Pipeline Status</h3>

                    <div class="pipeline-card" id="pipeline1">
                        <div class="pipeline-header">
                            <div>
                                <span class="pipeline-icon">&#127909;</span>
                                <span class="pipeline-name">Pipeline 1: RTSP Server</span>
                            </div>
                            <span class="pipeline-status-badge streaming" id="pipeline1-status">
                                <span class="status-dot connected"></span> STREAMING
                            </span>
                        </div>
                        <div class="pipeline-details">
                            <span><span class="label">Port:</span> <span class="value">8554</span></span>
                            <span><span class="label">Health:</span> <span class="value" id="pipeline1-health">Checking...</span></span>
                        </div>
                    </div>

                    <div class="pipeline-card" id="pipeline2">
                        <div class="pipeline-header">
                            <div>
                                <span class="pipeline-icon">&#127753;</span>
                                <span class="pipeline-name">Pipeline 2: SRT Bridge</span>
                            </div>
                            <span class="pipeline-status-badge streaming" id="pipeline2-status">
                                <span class="status-dot connected"></span> STREAMING
                            </span>
                        </div>
                        <div class="pipeline-details">
                            <span><span class="label">Port:</span> <span class="value">9002</span></span>
                            <span><span class="label">Health:</span> <span class="value" id="pipeline2-health">Checking...</span></span>
                        </div>
                    </div>

                    <div class="pipeline-card" id="pipeline3">
                        <div class="pipeline-header">
                            <div>
                                <span class="pipeline-icon">&#128225;</span>
                                <span class="pipeline-name">Pipeline 3: MediaMTX</span>
                            </div>
                            <span class="pipeline-status-badge streaming" id="pipeline3-status">
                                <span class="status-dot connected"></span> DISTRIBUTING
                            </span>
                        </div>
                        <div class="pipeline-details">
                            <span><span class="label">Ports:</span> <span class="value">8888, 8889, 9000</span></span>
                            <span><span class="label">Health:</span> <span class="value" id="pipeline3-health">Checking...</span></span>
                        </div>
                    </div>
                </div>

                <!-- Metrics -->
                <div class="metrics-section">
                    <h3>
                        <span>&#128202; System Metrics</span>
                        <span class="refresh-indicator">
                            <span class="refresh-dot"></span>
                            Live
                        </span>
                    </h3>

                    <div class="metrics-grid">
                        <div class="metric-card">
                            <div class="metric-value" id="totalViewers">0</div>
                            <div class="metric-label">Active Viewers</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value" id="bitrate">0</div>
                            <div class="metric-label">Bitrate (Mbps)</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value" id="uptime">0s</div>
                            <div class="metric-label">Uptime</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value" id="bytesTotal">0</div>
                            <div class="metric-label">Data Transfer</div>
                        </div>
                    </div>

                    <div class="connection-stats">
                        <h4>Connections by Protocol</h4>
                        <div class="stats-row">
                            <span class="label">WebRTC</span>
                            <span class="value" id="webrtcConns">0</span>
                        </div>
                        <div class="stats-row">
                            <span class="label">HLS</span>
                            <span class="value" id="hlsConns">0</span>
                        </div>
                        <div class="stats-row">
                            <span class="label">RTSP</span>
                            <span class="value" id="rtspConns">0</span>
                        </div>
                        <div class="stats-row">
                            <span class="label">SRT</span>
                            <span class="value" id="srtConns">0</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Protocol Info Table -->
        <div class="protocol-info">
            <table>
                <thead>
                    <tr>
                        <th>Protocol</th>
                        <th>URL</th>
                        <th>Latency</th>
                        <th>Use Case</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><span class="protocol-name">WebRTC</span></td>
                        <td class="url-cell" id="webrtc-url-cell">-</td>
                        <td><span class="latency-badge ultra-low">~200ms</span></td>
                        <td>Real-time interaction, browser playback</td>
                        <td><button class="btn btn-secondary copy-btn" onclick="copyUrl('webrtc-url-cell')">Copy URL</button></td>
                    </tr>
                    <tr>
                        <td><span class="protocol-name">HLS</span></td>
                        <td class="url-cell" id="hls-url-cell">-</td>
                        <td><span class="latency-badge high">~8s</span></td>
                        <td>Universal compatibility, CDN delivery</td>
                        <td><button class="btn btn-secondary copy-btn" onclick="copyUrl('hls-url-cell')">Copy URL</button></td>
                    </tr>
                    <tr>
                        <td><span class="protocol-name">RTSP</span></td>
                        <td class="url-cell" id="rtsp-url-cell">-</td>
                        <td><span class="latency-badge medium">~1s</span></td>
                        <td>IP cameras, surveillance systems</td>
                        <td><button class="btn btn-secondary copy-btn" onclick="copyUrl('rtsp-url-cell')">Copy URL</button></td>
                    </tr>
                    <tr>
                        <td><span class="protocol-name">SRT</span></td>
                        <td class="url-cell" id="srt-url-cell">-</td>
                        <td><span class="latency-badge low">~500ms</span></td>
                        <td>Broadcast contribution, unreliable networks</td>
                        <td><button class="btn btn-secondary copy-btn" onclick="copyUrl('srt-url-cell')">Copy URL</button></td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toast">
        <span id="toastMessage">URL copied to clipboard!</span>
    </div>

    <script>
        // Configuration
        const baseHost = window.location.hostname || 'localhost';
        const config = {
            webrtc: {
                whepUrl: `http://${baseHost}:8889/cam1/whep`,
                displayUrl: `http://${baseHost}:8889/cam1/whep`
            },
            hls: {
                url: `http://${baseHost}:8888/cam1/index.m3u8`
            },
            rtsp: {
                url: `rtsp://${baseHost}:8555/cam1`
            },
            srt: {
                url: `srt://${baseHost}:9000?streamid=read:cam1`
            },
            api: {
                paths: `http://${baseHost}:9997/v3/paths/list`,
                metrics: `http://${baseHost}:9998/metrics`
            },
            pipelines: {
                rtsp: `http://${baseHost}:9001/health`,
                srtBridge: `http://${baseHost}:9002/health`
            }
        };

        // State
        let currentProtocol = 'webrtc';
        let webrtcPc = null;
        let hlsPlayer = null;
        let isConnecting = false;
        let shouldReconnect = true;
        let reconnectTimeout = null;
        let metricsInterval = null;
        let lastBytesReceived = 0;
        let lastMetricsTime = Date.now();
        let streamStartTime = null;
        let hlsConnected = false;  // Client-side HLS connection tracking

        // DOM Elements
        const webrtcVideo = document.getElementById('webrtc-player');
        const hlsVideo = document.getElementById('hls-player');
        const rtspPanel = document.getElementById('rtsp-panel');
        const srtPanel = document.getElementById('srt-panel');
        const overlay = document.getElementById('overlay');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const playerTitle = document.getElementById('playerTitle');
        const overlayMessage = document.getElementById('overlayMessage');

        // Initialize URLs in the UI
        function initializeUrls() {
            document.getElementById('rtsp-url').value = config.rtsp.url;
            document.getElementById('srt-url').value = config.srt.url;

            document.querySelectorAll('.rtsp-url-text').forEach(el => el.textContent = config.rtsp.url);
            document.querySelectorAll('.srt-url-text').forEach(el => el.textContent = config.srt.url);

            document.getElementById('webrtc-url-cell').textContent = config.webrtc.displayUrl;
            document.getElementById('hls-url-cell').textContent = config.hls.url;
            document.getElementById('rtsp-url-cell').textContent = config.rtsp.url;
            document.getElementById('srt-url-cell').textContent = config.srt.url;
        }

        // Protocol Switching
        function switchProtocol(protocol) {
            // Stop current protocol
            stopAllPlayers();

            // Update UI
            document.querySelectorAll('.protocol-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.setAttribute('aria-selected', 'false');
            });
            document.querySelector(`.protocol-btn.${protocol}`).classList.add('active');
            document.querySelector(`.protocol-btn.${protocol}`).setAttribute('aria-selected', 'true');

            // Hide all players/panels
            webrtcVideo.classList.add('hidden');
            hlsVideo.classList.add('hidden');
            rtspPanel.classList.add('hidden');
            srtPanel.classList.add('hidden');

            // Update title
            const titles = {
                webrtc: 'Camera 1 - WebRTC',
                hls: 'Camera 1 - HLS',
                rtsp: 'Camera 1 - RTSP',
                srt: 'Camera 1 - SRT'
            };
            playerTitle.textContent = titles[protocol];

            currentProtocol = protocol;

            // Show appropriate player/panel
            switch (protocol) {
                case 'webrtc':
                    webrtcVideo.classList.remove('hidden');
                    shouldReconnect = true;
                    startWebRTC();
                    break;
                case 'hls':
                    hlsVideo.classList.remove('hidden');
                    shouldReconnect = true;
                    startHLS();
                    break;
                case 'rtsp':
                    rtspPanel.classList.remove('hidden');
                    hideOverlay();
                    setStatus('', 'External Player Required');
                    break;
                case 'srt':
                    srtPanel.classList.remove('hidden');
                    hideOverlay();
                    setStatus('', 'External Player Required');
                    break;
            }
        }

        // WebRTC Player
        async function startWebRTC() {
            if (isConnecting) return;
            isConnecting = true;

            setStatus('connecting', 'Connecting...');
            showOverlay('Connecting to WebRTC stream...');

            try {
                webrtcPc = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });

                webrtcPc.ontrack = (event) => {
                    console.log('WebRTC track received');
                    webrtcVideo.srcObject = event.streams[0];
                    setStatus('connected', 'Connected');
                    hideOverlay();
                    if (!streamStartTime) streamStartTime = Date.now();
                };

                webrtcPc.oniceconnectionstatechange = () => {
                    const state = webrtcPc.iceConnectionState;
                    console.log('ICE state:', state);

                    if (state === 'connected' || state === 'completed') {
                        setStatus('connected', 'Connected');
                        hideOverlay();
                    } else if (state === 'disconnected') {
                        setStatus('connecting', 'Reconnecting...');
                        showOverlay('Stream ended - reconnecting...');
                        scheduleReconnect(500);
                    } else if (state === 'failed' || state === 'closed') {
                        setStatus('connecting', 'Reconnecting...');
                        showOverlay('Connection lost - reconnecting...');
                        scheduleReconnect(1000);
                    }
                };

                webrtcPc.addTransceiver('video', { direction: 'recvonly' });
                webrtcPc.addTransceiver('audio', { direction: 'recvonly' });

                const offer = await webrtcPc.createOffer();
                await webrtcPc.setLocalDescription(offer);

                const response = await fetch(config.webrtc.whepUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/sdp' },
                    body: offer.sdp
                });

                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}`);
                }

                const answer = await response.text();
                await webrtcPc.setRemoteDescription({ type: 'answer', sdp: answer });

                isConnecting = false;

            } catch (err) {
                console.error('WebRTC error:', err);
                isConnecting = false;
                setStatus('connecting', 'Waiting for stream...');
                showOverlay('Waiting for stream...');
                scheduleReconnect(2000);
            }
        }

        // HLS Player
        function startHLS() {
            setStatus('connecting', 'Connecting...');
            showOverlay('Loading HLS stream...');

            if (Hls.isSupported()) {
                hlsPlayer = new Hls({
                    maxBufferLength: 10,
                    liveBackBufferLength: 0,
                    liveSyncDuration: 1,
                    liveMaxLatencyDuration: 5,
                    lowLatencyMode: true
                });

                hlsPlayer.loadSource(config.hls.url);
                hlsPlayer.attachMedia(hlsVideo);

                hlsPlayer.on(Hls.Events.MANIFEST_PARSED, () => {
                    console.log('HLS manifest parsed');
                    hlsVideo.play().catch(e => console.log('Autoplay prevented:', e));
                    setStatus('connected', 'Connected');
                    hideOverlay();
                    hlsConnected = true;
                    if (!streamStartTime) streamStartTime = Date.now();
                });

                hlsPlayer.on(Hls.Events.ERROR, (event, data) => {
                    console.error('HLS error:', data);
                    if (data.fatal) {
                        switch (data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                setStatus('error', 'Network Error');
                                showOverlay('Network error - retrying...');
                                hlsPlayer.startLoad();
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                setStatus('connecting', 'Recovering...');
                                hlsPlayer.recoverMediaError();
                                break;
                            default:
                                setStatus('error', 'Fatal Error');
                                showOverlay('Cannot play HLS stream');
                                break;
                        }
                    }
                });

            } else if (hlsVideo.canPlayType('application/vnd.apple.mpegurl')) {
                // Native HLS (Safari)
                hlsVideo.src = config.hls.url;
                hlsVideo.addEventListener('loadedmetadata', () => {
                    hlsVideo.play();
                    setStatus('connected', 'Connected');
                    hideOverlay();
                    hlsConnected = true;
                });
                hlsVideo.addEventListener('error', () => {
                    setStatus('error', 'Playback Error');
                    showOverlay('Cannot play HLS stream');
                });
            } else {
                setStatus('error', 'Not Supported');
                showOverlay('HLS is not supported in this browser');
            }
        }

        // Stop all players
        function stopAllPlayers() {
            shouldReconnect = false;

            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }

            // Stop WebRTC
            if (webrtcPc) {
                webrtcPc.close();
                webrtcPc = null;
            }
            webrtcVideo.srcObject = null;

            // Stop HLS
            if (hlsPlayer) {
                hlsPlayer.destroy();
                hlsPlayer = null;
            }
            hlsVideo.src = '';
            hlsConnected = false;

            isConnecting = false;
        }

        // UI Helpers
        function setStatus(status, text) {
            statusDot.className = 'status-dot ' + status;
            statusText.textContent = text;
        }

        function showOverlay(text) {
            overlayMessage.textContent = text;
            overlay.classList.remove('hidden');
        }

        function hideOverlay() {
            overlay.classList.add('hidden');
        }

        function scheduleReconnect(delay) {
            if (reconnectTimeout) clearTimeout(reconnectTimeout);
            if (shouldReconnect && (currentProtocol === 'webrtc' || currentProtocol === 'hls')) {
                reconnectTimeout = setTimeout(() => {
                    if (currentProtocol === 'webrtc') startWebRTC();
                    else if (currentProtocol === 'hls') startHLS();
                }, delay);
            }
        }

        function connectCurrentProtocol() {
            shouldReconnect = true;
            if (currentProtocol === 'webrtc') startWebRTC();
            else if (currentProtocol === 'hls') startHLS();
        }

        function disconnectCurrentProtocol() {
            stopAllPlayers();
            setStatus('', 'Disconnected');
            showOverlay('Disconnected');
        }

        // Copy to clipboard
        function copyUrl(elementId) {
            const element = document.getElementById(elementId);
            const text = element.value || element.textContent;

            navigator.clipboard.writeText(text).then(() => {
                showToast('URL copied to clipboard!', 'success');
            }).catch(err => {
                console.error('Copy failed:', err);
                showToast('Failed to copy URL', 'error');
            });
        }

        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toastMessage');

            toast.className = 'toast ' + type;
            toastMessage.textContent = message;
            toast.classList.add('show');

            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // Fullscreen
        function toggleFullscreen() {
            const container = document.querySelector('.video-container');
            if (!document.fullscreenElement) {
                container.requestFullscreen().catch(err => {
                    console.error('Fullscreen error:', err);
                });
            } else {
                document.exitFullscreen();
            }
        }

        // Picture-in-Picture
        async function togglePiP() {
            const video = currentProtocol === 'webrtc' ? webrtcVideo : hlsVideo;

            if (document.pictureInPictureElement) {
                await document.exitPictureInPicture();
            } else if (document.pictureInPictureEnabled && video.srcObject || video.src) {
                try {
                    await video.requestPictureInPicture();
                } catch (err) {
                    console.error('PiP error:', err);
                    showToast('Picture-in-Picture not available', 'error');
                }
            }
        }

        // Fetch metrics
        async function fetchMetrics() {
            try {
                // Fetch path info from API (most accurate for reader counts)
                const apiResponse = await fetch(config.api.paths);
                let webrtcCount = 0, hlsCount = 0, rtspCount = 0, srtCount = 0;

                if (apiResponse.ok) {
                    const data = await apiResponse.json();

                    const cam1 = data.items?.find(p => p.name === 'cam1');
                    if (cam1) {
                        // Calculate bitrate
                        const now = Date.now();
                        const timeDiff = (now - lastMetricsTime) / 1000;
                        const bytesDiff = (cam1.bytesReceived || 0) - lastBytesReceived;
                        const bitrate = timeDiff > 0 ? ((bytesDiff * 8) / timeDiff / 1000000).toFixed(2) : 0;

                        document.getElementById('bitrate').textContent = bitrate;
                        document.getElementById('bytesTotal').textContent = formatBytes(cam1.bytesReceived || 0);

                        lastBytesReceived = cam1.bytesReceived || 0;
                        lastMetricsTime = now;

                        // Count readers by type from API
                        if (cam1.readers) {
                            cam1.readers.forEach(reader => {
                                switch (reader.type) {
                                    case 'webRTCSession': webrtcCount++; break;
                                    // Skip hlsMuxer - use client-side tracking instead
                                    case 'rtspSession': rtspCount++; break;
                                    case 'srtConn': srtCount++; break;
                                }
                            });
                        }
                    }
                }

                // Use client-side HLS connection state (more accurate for browser connections)
                hlsCount = hlsConnected ? 1 : 0;

                // Update connection counts
                document.getElementById('webrtcConns').textContent = webrtcCount;
                document.getElementById('hlsConns').textContent = hlsCount;
                document.getElementById('rtspConns').textContent = rtspCount;
                document.getElementById('srtConns').textContent = srtCount;

                const totalViewers = webrtcCount + hlsCount + rtspCount + srtCount;
                document.getElementById('totalViewers').textContent = totalViewers;

                // Update uptime
                if (streamStartTime) {
                    document.getElementById('uptime').textContent = formatDuration(streamStartTime);
                }

            } catch (err) {
                console.error('Metrics fetch error:', err);
            }
        }

        // Check pipeline health
        async function checkPipelineHealth() {
            // Pipeline 1 - RTSP Server
            try {
                const resp1 = await fetch(config.pipelines.rtsp);
                updatePipelineStatus('pipeline1', resp1.ok);
                document.getElementById('pipeline1-health').textContent = resp1.ok ? 'Healthy' : 'Unhealthy';
            } catch {
                updatePipelineStatus('pipeline1', false);
                document.getElementById('pipeline1-health').textContent = 'Unreachable';
            }

            // Pipeline 2 - SRT Bridge
            try {
                const resp2 = await fetch(config.pipelines.srtBridge);
                updatePipelineStatus('pipeline2', resp2.ok);
                document.getElementById('pipeline2-health').textContent = resp2.ok ? 'Healthy' : 'Unhealthy';
            } catch {
                updatePipelineStatus('pipeline2', false);
                document.getElementById('pipeline2-health').textContent = 'Unreachable';
            }

            // Pipeline 3 - MediaMTX (check via API)
            try {
                const resp3 = await fetch(config.api.paths);
                updatePipelineStatus('pipeline3', resp3.ok);
                document.getElementById('pipeline3-health').textContent = resp3.ok ? 'Healthy' : 'Unhealthy';
            } catch {
                updatePipelineStatus('pipeline3', false);
                document.getElementById('pipeline3-health').textContent = 'Unreachable';
            }

            // Update system status
            updateSystemStatus();
        }

        function updatePipelineStatus(pipelineId, isHealthy) {
            const statusBadge = document.getElementById(`${pipelineId}-status`);
            if (isHealthy) {
                statusBadge.className = 'pipeline-status-badge streaming';
                statusBadge.innerHTML = '<span class="status-dot connected"></span> ' +
                    (pipelineId === 'pipeline3' ? 'DISTRIBUTING' : 'STREAMING');
            } else {
                statusBadge.className = 'pipeline-status-badge error';
                statusBadge.innerHTML = '<span class="status-dot error"></span> OFFLINE';
            }
        }

        function updateSystemStatus() {
            const statuses = document.querySelectorAll('.pipeline-status-badge');
            let allHealthy = true;
            let anyHealthy = false;

            statuses.forEach(badge => {
                if (badge.classList.contains('streaming')) anyHealthy = true;
                else allHealthy = false;
            });

            const systemStatus = document.getElementById('systemStatus');
            if (allHealthy) {
                systemStatus.className = 'system-status';
                systemStatus.innerHTML = '<span class="status-dot connected"></span><span>All Systems Operational</span>';
            } else if (anyHealthy) {
                systemStatus.className = 'system-status warning';
                systemStatus.innerHTML = '<span class="status-dot connecting"></span><span>Partial System Outage</span>';
            } else {
                systemStatus.className = 'system-status error';
                systemStatus.innerHTML = '<span class="status-dot error"></span><span>System Offline</span>';
            }
        }

        // Utility functions
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        function formatDuration(startTime) {
            const diff = Math.floor((Date.now() - startTime) / 1000);
            const hours = Math.floor(diff / 3600);
            const mins = Math.floor((diff % 3600) / 60);
            const secs = diff % 60;

            if (hours > 0) return `${hours}h ${mins}m`;
            if (mins > 0) return `${mins}m ${secs}s`;
            return `${secs}s`;
        }

        // Keyboard navigation
        document.querySelectorAll('.protocol-btn').forEach((btn) => {
            btn.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    switchProtocol(btn.dataset.protocol);
                }
            });
        });

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            initializeUrls();

            // Start metrics polling
            fetchMetrics();
            checkPipelineHealth();
            metricsInterval = setInterval(fetchMetrics, 5000);
            setInterval(checkPipelineHealth, 10000);

            // Auto-connect WebRTC
            setTimeout(() => startWebRTC(), 500);
        });
    </script>
</body>
</html>
